var flatSurface = $("#surface-shader"); if (flatSurface.length) var rendererFSS, sceneFSS, mesh, geometry, material, canvasRenderer, now, MESH = { width: 1.2, height: 1.2, depth: 0, segments: 16, slices: 8, xRange: .8, yRange: .1, zRange: 1, ambient: "#555555", diffuse: "#ffffff", speed: .002 }, LIGHT = { count: 2, xyScalar: 1, zOffset: 100, ambient: flatSurface.data("ambient-color"), diffuse: flatSurface.data("diffuse-color"), speed: .002, gravity: 500, dampening: .95, minLimit: 10, maxLimit: null, minDistance: 20, maxDistance: 800, autopilot: !0, draw: !1, bounds: FSS.Vector3.create(), step: FSS.Vector3.create(Math.randomInRange(.2, 1), Math.randomInRange(.2, 1), Math.randomInRange(.2, 1)) }, RENDER = { renderer: "canvas" }, start = Date.now(), center = FSS.Vector3.create(), attractor = FSS.Vector3.create(), containerFSS = flatSurface[0], output = flatSurface[0]; function initialise() { createRenderer(), createScene(), createMesh(), createLights(), addEventListeners(), resize(containerFSS.offsetWidth, containerFSS.offsetHeight), animateFSS() } function createRenderer() { canvasRenderer = new FSS.CanvasRenderer, setRenderer(RENDER.renderer) } function setRenderer() { rendererFSS && output.removeChild(rendererFSS.element), (rendererFSS = canvasRenderer).setSize(containerFSS.offsetWidth, containerFSS.offsetHeight), output.appendChild(rendererFSS.element) } function createScene() { sceneFSS = new FSS.Scene } function createMesh() { var a, b; for (sceneFSS.remove(mesh), rendererFSS.clear(), geometry = new FSS.Plane(MESH.width * rendererFSS.width, MESH.height * rendererFSS.height, MESH.segments, MESH.slices), material = new FSS.Material(MESH.ambient, MESH.diffuse), mesh = new FSS.Mesh(geometry, material), sceneFSS.add(mesh), a = geometry.vertices.length - 1; a >= 0; a--)(b = geometry.vertices[a]).anchor = FSS.Vector3.clone(b.position), b.step = FSS.Vector3.create(Math.randomInRange(.2, 1), Math.randomInRange(.2, 1), Math.randomInRange(.2, 1)), b.time = Math.randomInRange(0, Math.PIM2) } function createLights() { var b, a; for (b = sceneFSS.lights.length - 1; b >= 0; b--)a = sceneFSS.lights[b], sceneFSS.remove(a); for (rendererFSS.clear(), b = 0; b < LIGHT.count; b++)(a = new FSS.Light(LIGHT.ambient, LIGHT.diffuse)).ambientHex = a.ambient.format(), a.diffuseHex = a.diffuse.format(), sceneFSS.add(a), a.mass = Math.randomInRange(.5, 1), a.velocity = FSS.Vector3.create(), a.acceleration = FSS.Vector3.create(), a.force = FSS.Vector3.create(), a.ring = document.createElementNS(FSS.SVGNS, "circle"), a.ring.setAttributeNS(null, "stroke", a.ambientHex), a.ring.setAttributeNS(null, "stroke-width", "0.5"), a.ring.setAttributeNS(null, "fill", "none"), a.ring.setAttributeNS(null, "r", "10"), a.core = document.createElementNS(FSS.SVGNS, "circle"), a.core.setAttributeNS(null, "fill", a.diffuseHex), a.core.setAttributeNS(null, "r", "4") } function resize(a, b) { rendererFSS.setSize(a, b), FSS.Vector3.set(center, rendererFSS.halfWidth, rendererFSS.halfHeight), createMesh() } function animateFSS() { now = Date.now() - start, update(), renderFSS(), requestAnimationFrame(animateFSS) } function update() { var c, d, g, e, a, f, b, h = MESH.depth / 2; for (FSS.Vector3.copy(LIGHT.bounds, center), FSS.Vector3.multiplyScalar(LIGHT.bounds, LIGHT.xyScalar), FSS.Vector3.setZ(attractor, LIGHT.zOffset), LIGHT.autopilot && (c = Math.sin(LIGHT.step[0] * now * LIGHT.speed), d = Math.cos(LIGHT.step[1] * now * LIGHT.speed), FSS.Vector3.set(attractor, LIGHT.bounds[0] * c, LIGHT.bounds[1] * d, LIGHT.zOffset)), e = sceneFSS.lights.length - 1; e >= 0; e--) { a = sceneFSS.lights[e], FSS.Vector3.setZ(a.position, LIGHT.zOffset); var i = Math.clamp(FSS.Vector3.distanceSquared(a.position, attractor), LIGHT.minDistance, LIGHT.maxDistance), j = LIGHT.gravity * a.mass / i; FSS.Vector3.subtractVectors(a.force, attractor, a.position), FSS.Vector3.normalise(a.force), FSS.Vector3.multiplyScalar(a.force, j), FSS.Vector3.set(a.acceleration), FSS.Vector3.add(a.acceleration, a.force), FSS.Vector3.add(a.velocity, a.acceleration), FSS.Vector3.multiplyScalar(a.velocity, LIGHT.dampening), FSS.Vector3.limit(a.velocity, LIGHT.minLimit, LIGHT.maxLimit), FSS.Vector3.add(a.position, a.velocity) } for (f = geometry.vertices.length - 1; f >= 0; f--)c = Math.sin((b = geometry.vertices[f]).time + b.step[0] * now * MESH.speed), d = Math.cos(b.time + b.step[1] * now * MESH.speed), g = Math.sin(b.time + b.step[2] * now * MESH.speed), FSS.Vector3.set(b.position, MESH.xRange * geometry.segmentWidth * c, MESH.yRange * geometry.sliceHeight * d, MESH.zRange * h * g - h), FSS.Vector3.add(b.position, b.anchor); geometry.dirty = !0 } function renderFSS() { if (rendererFSS.render(sceneFSS), LIGHT.draw) { var a, c, d, b; for (a = sceneFSS.lights.length - 1; a >= 0; a--)c = (b = sceneFSS.lights[a]).position[0], d = b.position[1], rendererFSS.context.lineWidth = .5, rendererFSS.context.beginPath(), rendererFSS.context.arc(c, d, 10, 0, Math.PIM2), rendererFSS.context.strokeStyle = b.ambientHex, rendererFSS.context.stroke(), rendererFSS.context.beginPath(), rendererFSS.context.arc(c, d, 4, 0, Math.PIM2), rendererFSS.context.fillStyle = b.diffuseHex, rendererFSS.context.fill() } } function addEventListeners() { window.addEventListener("resize", onWindowResizFSS) } function onWindowResizFSS() { resize(containerFSS.offsetWidth, containerFSS.offsetHeight), renderFSS() } flatSurface.length && initialise()